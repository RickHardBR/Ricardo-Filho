# Criptografia

<h2 id="topo">Conte√∫do</h2>

## O que esperamos que voc√™ entenda com essa aula?

- Com usar o bcryptjs para salvar a senha do usu√°rio;

---

## Exerc√≠cios

   * [O que funciona](#funciona)
       * [1 - Exercicio 1](#exer1)
         * [a-1) - O que s√£o os round e salt?](#rs)
         * [a-2) - Que valores s√£o recomendados para o round](#vr)
         * [a-3) - Que valor voc√™ usou](#vru)
         * [a-4) - Por qu√™](#pq)
       * [2 - Exercicio 2](#exer2)
         * [a) - Para realizar os testes corretamente, qual deles voc√™ deve modificar primeiro? O cadastro ou o login? Justifique.](#signup)
         * [b) - Fa√ßa a altera√ß√£o do primeiro endpoint](#pe)
         * [c) - Fa√ßa a altera√ß√£o do segundo endpoint](#se)
         * [d) - No exerc√≠cio da aula anterior, n√≥s criamos o endpoint user/profile. Tamb√©m temos que modificar esse endpoint devido √† adi√ß√£o da criptografia? Justifique.](#pf)
- üìñ Enunciado
    
    ### Instru√ß√µes gerais
    
    No exerc√≠cio de hoje, vamos treinar as modifica√ß√µes que fizemos na aula: adicionar a criptografia. Voc√™ pode fazer o projeto do zero, a partir de uma pasta que voc√™ mesmo criar. Para isso, reunimos as instru√ß√µes principais aqui:
    
    ### Inicie o projeto por aqui
    
    <aside>
    ‚ö†Ô∏è **IMPORTANTE** ‚ö†Ô∏è
    
    1) Crie uma branch **a partir da branch master** para trabalhar no exerc√≠cio de hoje. O nome da branch de hoje deve ser: `criptografia-e-user-roles`
    
    2) Dentro da pasta do m√≥dulo atual, crie uma pasta chamada `criptografia-e-user-roles` para trabalhar no exerc√≠cio de hoje
    
    3) N√£o esque√ßa de entregar o arquivo `requests.rest` com os endpoints!
    
    </aside>
    
    ### Agora, fa√ßa os exerc√≠cios propostos
    
    Durante os exerc√≠cios, vamos fazer algumas perguntas para voc√™. Responda-as em um arquivo *markdown* (veja as instru√ß√µes no notion das semanas anteriores, caso precise).
    
    <h2 id="exer1">- Exerc√≠cio 1</h2>
        
        A primeira implementa√ß√£o que vamos fazer refere-se √† fun√ß√£o que vai cuidar do hash da nossa senha. Vamos utilizar um bem famoso e muito recomendado para senhas de usu√°rios: *bcryptjs*. A principal vantagem dele √© que √© gerada uma string aleat√≥ria e atrelada √† entrada da criptografia. Isso **impede** que se fa√ßa o ataque chamado de ***rainbow table*,** que consiste em montar uma tabela com infinitas possibilidades da sa√≠da do *hash*. 
        
        Abaixo, h√° o exemplo de uso da fun√ß√£o de *hash*
        
        ```tsx
        import * as bcrypt from "bcryptjs";
        
        const rounds = Number(process.env.BCRYPT_COST);
        const salt = await bcrypt.genSalt(rounds);
        const result = await bcrypt.hash(s, salt);
        console.log("encrypted message: ", result);
        ```
        
    a) *O que s√£o os `round` e `salt`? Que valores s√£o recomendados para o `round`? Que valor voc√™ usou? Por qu√™?*

<h4 align="right"><a href="#topo">Topo‚¨ÜÔ∏è</a></h4>

* <h3 id="rs">a-1): O que s√£o os round e salt?</h3>
        * R): O `Cost` ou Round determina o tempo de execu√ß√£o do algor√≠timo e `Salt` nada mais √© do que a sua garantia de que, dado um salt aleat√≥rio, a mesma senha nunca ser√° igualmente hasheada duas vezes.
#

<h4 align="right"><a href="#topo">Topo‚¨ÜÔ∏è</a></h4>

* <h3 id="vr">a-2): Que valores s√£o recomendados para o round?</h3>
        * R): O valor padr√£o recomendado √© 12
#

<h4 align="right"><a href="#topo">Topo‚¨ÜÔ∏è</a></h4>

* <h3 id="vru">a-3): Que valor voc√™ usou?</h3>
        * R): 12
#

<h4 align="right"><a href="#topo">Topo‚¨ÜÔ∏è</a></h4>

* <h3 id="pq">a-4): Por qu√™?</h3>
        * R): Porque √© o valor padr√£o "12" da maioria das libs e quanto maior melhor para a seguran√ßa, mas demanda mais tempo de execu√ß√£o, deve ser utilizado levando-se em conta o equipamento utilizados.
#

<h4 align="right"><a href="#topo">Topo‚¨ÜÔ∏è</a></h4>

        b) *Instale o bcryptjs no seu projeto e comece criando a fun√ß√£o generateHash(), que ser√° respons√°vel por **criptografar** uma string usando o bcryptjs.  ***** 
        
        c) *Agora, crie a fun√ß√£o que verifique se uma string √© correspondente a um hash, use a fun√ß√£o `compare` do bcryptjs*

<h4 align="right"><a href="#topo">Topo‚¨ÜÔ∏è</a></h4>

![image](https://user-images.githubusercontent.com/89301596/174416692-13197d09-bc15-4875-9132-bde68efab1e4.png)
            
<h4 align="right"><a href="#topo">Topo‚¨ÜÔ∏è</a></h4>

    - Exerc√≠cio 2
        
        Na aula anterior, implementamos os endpoints de *signup* e *login* sem utilizar a criptografia. Vamos agora colocar isso. A ideia √© simples: **no cadastro**, antes de salvar o usu√°rio no banco, temos que **criptografar** a senha, para que, no banco, n√£o fique a senha em si. J√°, **no login**, em vez de comparar a senha enviada diretamente com a salva no banco, usaremos a biblioteca de *Hash* para isso. 
        
<h3 id="signup">a) Para realizar os testes corretamente, qual deles voc√™ deve modificar primeiro? O cadastro ou o login? Justifique.*</h3>

        R):  Devemos modificar primeiro o de cadastro "signup", para que o usu√°rio j√° seja cadastrado e sua senha criptografada.

<h4 align="right"><a href="#topo">Topo‚¨ÜÔ∏è</a></h4>

<h3 id="pe">b) *Fa√ßa a altera√ß√£o do primeiro endpoint*</h3>

![image](https://user-images.githubusercontent.com/89301596/174416908-4a9e35ac-06f5-4218-ad9e-f55dec01840d.png)

<h4 align="right"><a href="#topo">Topo‚¨ÜÔ∏è</a></h4>

<h3 id="se">c) *Fa√ßa a altera√ß√£o do segundo endpoint*</h3>

![image](https://user-images.githubusercontent.com/89301596/174416993-bbe6059c-9836-4a91-8de6-30271ffa1355.png)

<h4 align="right"><a href="#topo">Topo‚¨ÜÔ∏è</a></h4>

<h3 id="pf">d) *No exerc√≠cio da aula anterior, n√≥s criamos o endpoint `user/profile`. Tamb√©m temos que modificar esse endpoint devido √† adi√ß√£o da criptografia? Justifique.*</h3>
        
        R):  N√£o precisa, pois ele apenas pega as informa√ß√µes sem precisar de criptografia
<h4 align="right"><a href="#topo">Topo‚¨ÜÔ∏è</a></h4>